{"version":3,"file":"component---src-pages-arts-snakegame-snake-game-tsx-8d33a27424087e4efb91.js","mappings":"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","sources":["webpack://gatsby-starter-default/./src/pages/arts/snakegame/SnakeGame.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\n\n// Define types\ntype Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT';\ntype Cell = { x: number; y: number };\n\nconst gridSize = 10;\n\nconst SnakeGame: React.FC = () => {\n    const [snake, setSnake] = useState<Cell[]>([{ x: 1, y: 2 }]);\n    const [direction, setDirection] = useState<Direction>('RIGHT');\n    const [food, setFood] = useState<Cell>({ x: 5, y: 5 });\n\n    // Handle arrow key presses\n    useEffect(() => {\n        const handleKeydown = (e: KeyboardEvent) => {\n            switch (e.key) {\n                case 'ArrowUp': setDirection('UP'); break;\n                case 'ArrowDown': setDirection('DOWN'); break;\n                case 'ArrowLeft': setDirection('LEFT'); break;\n                case 'ArrowRight': setDirection('RIGHT'); break;\n            }\n        };\n\n        window.addEventListener('keydown', handleKeydown);\n\n        return () => window.removeEventListener('keydown', handleKeydown);\n    }, []);\n\n    useEffect(() => {\n        const gameInterval = setInterval(() => {\n            let newSnake = snake.map(cell => ({ ...cell }));\n\n            let head = Object.assign({}, newSnake[0]);\n\n\n\t\t\t//1. 방향키를 누른 방향으로 1칸 이동한다.\n\t\t\t//2. 벽에 충돌하면 시계방향으로 자동 회전한다.\n\t\t\t//3. 내 꼬리에 닿으면 게임 종료\n            switch (direction) {\n                case 'UP':\n\t\t\t\t\tif(newSnake.some(e => e.x == head.x && e.y == head.y-1)) {\n\t\t\t\t\t\talert(\"game ended!\");\n\t\t\t\t\t\tclearInterval(gameInterval);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(head.y - 1 < 0) {\n\t\t\t\t\t\thead.x += 1;\n\t\t\t\t\t\tsetDirection('RIGHT');\n\t\t\t\t\t} else {\n\t\t\t\t\t\thead.y -= 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n                case 'DOWN':\n\t\t\t\t\tif(newSnake.some(e => e.x == head.x && e.y == head.y+1)) {\n\t\t\t\t\t\talert(\"game ended!\");\n\t\t\t\t\t\tclearInterval(gameInterval);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(head.y + 1 >= gridSize) {\n\t\t\t\t\t\thead.x -= 1;\n\t\t\t\t\t\tsetDirection('LEFT');\n\t\t\t\t\t} else {\n\t\t\t\t\t\thead.y += 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n                case 'LEFT':\n\t\t\t\t\tif(newSnake.some(e => e.x == head.x - 1 && e.y == head.y)) {\n\t\t\t\t\t\talert(\"game ended!\");\n\t\t\t\t\t\tclearInterval(gameInterval);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(head.x - 1 < 0) {\n\t\t\t\t\t\thead.y -= 1;\n\t\t\t\t\t\tsetDirection('UP');\n\t\t\t\t\t} else {\n\t\t\t\t\t\thead.x -= 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n                case 'RIGHT':\n\t\t\t\t\tif(newSnake.some(e => e.x == head.x + 1 && e.y == head.y)) {\n\t\t\t\t\t\talert(\"game ended!\");\n\t\t\t\t\t\tclearInterval(gameInterval);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(head.x + 1 >= gridSize) {\n\t\t\t\t\t\thead.y += 1;\n\t\t\t\t\t\tsetDirection('DOWN');\n\t\t\t\t\t} else {\n\t\t\t\t\t\thead.x += 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n            }\n\n\n\t\t\t//food를 먹었다면\n\t\t\tif(head.x == food.x && head.y == food.y) {\n\t\t\t\tnewSnake = [head, ...newSnake.slice(0)];\n\n\t\t\t\t//다음 food의 위치의 조건  1. grid size 안  2. snake의 위치가 아닌 곳  3. 랜덤\n\t\t\t\tlet newFoodX = Math.floor(Math.random() * gridSize);\n\t\t\t\tlet newFoodY = Math.floor(Math.random() * gridSize);\n\n\t\t\t\twhile(newSnake.some(e => e.x == newFoodX && e.y == newFoodY)) {\n\t\t\t\t\tnewFoodX = Math.floor(Math.random() * gridSize);\n\t\t\t\t\tnewFoodY = Math.floor(Math.random() * gridSize);\n\t\t\t\t}\n\n\t\t\t\tsetFood({x:newFoodX, y:newFoodY});\n\t\t\t}\n\n            newSnake = [head, ...newSnake.slice(0, -1)]; //새로 움직인 head + 기존 array 병합\n\n            setSnake(newSnake);\n        }, 100);\n\n        return () => clearInterval(gameInterval);\n    }, [snake, direction]);\n\n    return (\n        <div style={{ display: 'grid', gridTemplateColumns: `repeat(${gridSize}, 20px)` }}>\n            {Array.from({ length: gridSize * gridSize }).map((_, index) => {\n                const x = index % gridSize;\n                const y = Math.floor(index / gridSize);\n\n\t\t\t\tconst isSnake = snake.some(cell => cell.x === x && cell.y === y);\n                const isFood = food.x === x && food.y === y;\n\n                return (\n                    <div\n                        key={index}\n                        style={{\n                            width: '20px',\n                            height: '20px',\n                            border: '1px solid gray',\n                            backgroundColor: isSnake ? 'green' : isFood ? 'red' : 'white'\n                        }}\n                    />\n                );\n            })}\n        </div>\n    );\n};\n\nexport default SnakeGame;\n\n"],"names":["gridSize","useState","x","y","snake","setSnake","direction","setDirection","food","setFood","useEffect","handleKeydown","e","key","window","addEventListener","removeEventListener","gameInterval","setInterval","newSnake","map","cell","head","Object","assign","some","alert","clearInterval","slice","newFoodX","Math","floor","random","newFoodY","style","display","gridTemplateColumns","Array","from","length","_","index","isSnake","isFood","width","height","border","backgroundColor"],"sourceRoot":""}